#include "int24.hh"

using std::pair;

pair<bool, int24_t> int24_t::add_with_overflow(int24_t other) const noexcept {
    // This function took far longer than I'd like to admit to write.
    // TL;DR: I generated assembly using Swift, optimized the calling convention by hand, and then translated that
    //        assembly line-for-line back to C++. I originally even looked at assembly because I thought I needed `seto`
    //        (I don't).
    // Ironically, the assembly generated has the instructions in a different order than I've written here. And there's
    // only a correspondence at all with clang or gcc -- MSVC spits out an unoptimized dumpster fire even with /O2.
    // The signedness of edx and eax matters for the interpretation of the rightshifts.
    int32_t edi = this->value + other.value;
    int32_t edx = edi;
    edx <<= 8;
    edx >>= 31;
    uint32_t eax = reinterpret_cast<const uint32_t&>(edi);
    eax >>= 23;
    eax &= 1;
    edi &= 8388607;
    edx &= -8388608;
    edi |= edx;
    return { static_cast<bool>(eax), int24_t{ edi } };
}

pair<bool, int24_t> int24_t::subtract_with_overflow(int24_t other) const noexcept {
    bool overflow;
    if (other.value > 0) {
        overflow = other.value > this->value - INT24_MIN.value;
    } else {
        overflow = other.value < this->value - INT24_MAX.value;
    }

    return { overflow, int24_t{ this->value - other.value } };
}

pair<bool, int24_t> int24_t::multiply_with_overflow(int24_t other) const noexcept {
    bool overflow;
#if ASM_ALLOWED
    int32_t lhs = this->value;
    const int32_t rhs = other.value;

    /* The assembly below was generated by Rust 1.69 from this source code. There is no way to write it in C++.
        pub fn mul(a: i32, b: i32) -> (bool, i32) {
            let x = a.overflowing_mul(b);
            if x.0 > 0x007fffff {
                (true, x.0 & 0x007fffff)
            } else if x.0 < -0x00800000 {
                (true, x.0 | -0x00800000)
            } else {
                (x.1, x.0)
            }
        }
    I have removed the last two instructions (movl %edi, %edx; retq), as they aren't needed here. */

    asm("\timull   %2, %1\n"
        "\tseto    %0\n"
        "\tcmpl    $8388607, %1\n"
        "\tjle     .LBB%=_1\n"
        "\tandl    $8388607, %1\n"
        "\tjmp     .LBB%=_4\n"
        ".LBB%=_1:\n"
        "\tcmpl    $-8388608, %1\n"
        "\tjge     .LBB%=_5\n"
        "\torl     $-8388608, %1\n"
        ".LBB%=_4:\n"
        "\tmovb    $1, %0\n"
        ".LBB%=_5:\n"
        : "=rm"(overflow), "+r"(lhs)
        : "rm"(rhs)
        : "cc");
    return { overflow, int24_t{ lhs } };
#else
    if (this->value == 0 || other.value == 0) {
        return { false, INT24_C(0) };
    }

    if (this->value > 0) {
        if (other.value > 0) {
            overflow = (other.value > INT24_MAX.value / this->value);
        } else {
            overflow = (other.value < INT24_MIN.value / this->value);
        }
    } else if (other.value > 0) {
        overflow = (other.value > INT24_MIN.value / this->value);
    } else {
        overflow = (other.value < INT24_MAX.value / this->value);
    }

    return { overflow, int24_t{ this->value * other.value } };
#endif
}
