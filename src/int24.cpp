#include "int24.hh"

using std::pair;

pair<bool, int24_t> int24_t::add_with_overflow(int24_t other) const noexcept {
    bool overflow;
    // I tried some clever bitwise magic before, but it didn't work.
    if (this->value > 0) {
        overflow = other.value > INT24_MAX.value - this->value;
    } else {
        overflow = other.value < INT24_MIN.value - this->value;
    }

    return { overflow, int24_t{ this->value + other.value } };
}

pair<bool, int24_t> int24_t::subtract_with_overflow(int24_t other) const noexcept {
    bool overflow;
    if (other.value > 0) {
        overflow = other.value > this->value - INT24_MIN.value;
    } else {
        overflow = other.value < this->value - INT24_MAX.value;
    }

    return { overflow, int24_t{ this->value - other.value } };
}

pair<bool, int24_t> int24_t::multiply_with_overflow(int24_t other) const noexcept {
    bool overflow;
#if ASM_ALLOWED
    int32_t lhs = this->value;
    const int32_t rhs = other.value;

    /* The assembly below was generated by Rust 1.69 from this source code. There is no way to write it in C++.
        pub fn mul(a: i32, b: i32) -> (bool, i32) {
            let x = a.overflowing_mul(b);
            if x.0 > 0x007fffff {
                (true, x.0 & 0x007fffff)
            } else if x.0 < -0x00800000 {
                (true, x.0 | -0x00800000)
            } else {
                (x.1, x.0)
            }
        }
    I have removed the last two instructions (movl %edi, %edx; retq), as they aren't needed here. */

    asm("\timull   %2, %1\n"
        "\tseto    %0\n"
        "\tcmpl    $8388607, %1\n"
        "\tjle     .LBB%=_1\n"
        "\tandl    $8388607, %1\n"
        "\tjmp     .LBB%=_4\n"
        ".LBB%=_1:\n"
        "\tcmpl    $-8388608, %1\n"
        "\tjge     .LBB%=_5\n"
        "\torl     $-8388608, %1\n"
        ".LBB%=_4:\n"
        "\tmovb    $1, %0\n"
        ".LBB%=_5:\n"
        : "=rm"(overflow), "+r"(lhs)
        : "rm"(rhs)
        : "cc");
    return { overflow, int24_t{ lhs } };
#else
    if (this->value == 0 || other.value == 0) {
        return { false, INT24_C(0) };
    }

    if (this->value > 0) {
        if (other.value > 0) {
            overflow = (other.value > INT24_MAX.value / this->value);
        } else {
            overflow = (other.value < INT24_MIN.value / this->value);
        }
    } else if (other.value > 0) {
        overflow = (other.value > INT24_MIN.value / this->value);
    } else {
        overflow = (other.value < INT24_MAX.value / this->value);
    }

    return { overflow, int24_t{ this->value * other.value } };
#endif
}
