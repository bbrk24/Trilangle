declare class ExitStatus extends Error {}
declare var Module:
  preInit: () => void
  onRuntimeInitialized: () => void
  noExitRuntime: boolean
  ccall(
    func: string,
    retType: null | 'string' | 'number',
    argTypes: readonly ('string' | 'number')[],
    args: readonly (string | number)[],
    options?: { readonly async?: boolean }
  ): undefined | number | string | Promise<undefined | number | string>
declare var FS:
  init(
    stdin: () => (number | null),
    stdout: (char: number | null) => void,
    stderr: (char: number | null) => void
  ): void

inputIndex .= 0
ready .= false
let stdinBuffer: Uint8Array
programText .= ''
let funcName: string | undefined
encoder := new TextEncoder
signals := new Map<string | undefined, () => void>

halfReady := (arg?: string): void ->
  funcName = arg ?? funcName
  unless ready
    ready = true
    return
  signal := signals.get funcName
  if signal?
    signal()
  else
    console.error `Unrecognized signal ${funcName}`
    postMessage [0, null]

Module['preInit'] = ->
  stdin := -> if inputIndex >= stdinBuffer.length then null else stdinBuffer.at(inputIndex++)!
  stdout := (char: number | null) -> postMessage [1, char]
  stderr := (char: number | null) -> postMessage [2, char]
  FS.init stdin, stdout, stderr
Module['onRuntimeInitialized'] = halfReady
Module['noExitRuntime'] = true

callInterpreter := (warnings: 0 | 1, disassemble: 0 | 1, expand: 0 | 1) -> ->
  inputIndex = 0
  try
    await Module['ccall'] 'wasm_entrypoint',
      null,
      ['string', 'number', 'number', 'number'],
      [programText, warnings, disassemble, expand],
      async: true
  catch e
    if e? !<? ExitStatus
      postMessage [2, e.toString()]
  postMessage [0, null]

signals.set 'interpretProgram', callInterpreter 0, 0, 0
signals.set 'disassembleProgram', callInterpreter 1, 0, 0
signals.set 'expandInput', callInterpreter 0, 1, 0
signals.set 'debugProgram', callInterpreter 0, 0, 1
// @ts-expect-error
signals.set 'step', => @['__trilangle_resolve']()

@onmessage = (event: MessageEvent<[string, string, string]>) ->
  if event.data.length > 1
    stdinBuffer = encoder.encode event.data[2]
    programText = event.data[1]
  halfReady event.data[0]
